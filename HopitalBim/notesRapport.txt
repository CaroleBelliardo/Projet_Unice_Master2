#-- Spécif. générale ou cas utilisation 
Lors de l'enregistrement d'un service seule les information générale sur le service ( tables 'Services' et 'Localisation' ) sont renseignée. On peut supposer que chaque service peut dispenser un nombre variable d'intervention et qu'il est plus pertinent de géré la liste des actes médicaux de manière indépendante. 




#-- Pour les tests unitaires : 

Pour garantir la fonctionnalité du notre projet, des tests unitaire ont été réalisés à chaque étape d'implémentation. Lors de l'utilisation de nouvelles fonction native, nous avons consulté le résultat retourné par celle-ci pour bien évaluer ce que fait concrètement la fonction avant de multiplier son utilisation. Aussi, durant l'implémentation de nouvelles fonctions ou procédures, nous avons testé pas à pas les effets de chaque instruction utilisée. 

Pour visualisé de manière formatée la structure des données de type tableau, nous avons créer la fonction Dumper() basé sur l'instruction var_dump. En effet, nous avons aussi consulter le contenu des différentes variables manipulées et ce particulièrement dans le cas de retour de requête SQL. En effet, l'existance de différent type d'instruction et d'options pour le 'Fetch' est pratique et permet d'adapter la structure de la variable de retour en fonction du résultat attendu. Cependant lors des premières utilisations, il est assez difficile  de reelement appréhender le retour de la requête et d'évaluer comment traiter la traiter. On peut noter cette difficulté notamment lors de l'élaboration de test conditionnel pour la gestion d'erreur relative au retour de requête vide. Par exemple, l'instruction Fetch(PDO::FETCH_ASSOC) retour un tableau dont les clefs sont les attributs sélectionnés ou un booléen 'FALSE' s'il n'y a pas de correspondance dans la table. En revanche, l'instruction fetchColumn() retourne une chaîne de caractère correspondant à la valeur d'attribut ou une chaîne vide s'il n'y a pas de correspondance. Ainsi, les tests conditionnels a mettre en place peuvent être très variable selon le mode de traitement des retours de requête. Le parcours des différents blocs d'instructions lors de l'élaboration de test, nous a permis d'évaluer la pertinance des test établit. 

Aussi, lors de l'emploi de structures de contrôle de type boucle, utilisées pour automatiser certaine procédures telles que la réitération de requêtes ou la génération dynamique de code HTML, nous avons évalué le comportement de celle-ci pour contrôler que le nombre d'itération correspondent à celui attendu. 
La structure des formulaires et du CSS a été évalué de manière visuelle sur les pages associées.  On a aussi testé les valeurs des variables associées code HTML de type 'form'  et les instruction associées aux boutons inclue dans ce type de code. 

L'intégrité de la structure de la base de donnée à été testé de manière visuelle sur l'interface phpMyadmin ( clés, nombre de colonnes, typage des attributs...). L'interface à aussi été utilisée lors de la conception des requêtes nécéssaire au fonctionnement de la plateforme. En effet, cette interface présente trop avantages à nos yeux, elle permet l'exécution individuelle de la requête, le retour est consultable immédiatement et enfin elle offre une option de complémentation des noms d'attributs.
Aussi, phpMyadmin nous a permis de tester l'opérabilité des formulaire réalisés à l'heure ou notre interface ne le permettait pas encore mais aussi pour les données qui ne sont pas visualisable ( pas exemple, les données de la table Pathologies ).





#-- Spécifications détaillées : 
1. Hypothèses : 
- tous les services travailles 7/7, pas de weed-end
- il ne peux pas y avoir deux services avec le même nom
- chaque acte à un tarif unique, pas de prix spéciaux pour les urgences
- l'administrateur est un informaticien qui ne prends pas partie aux transactions de rdv au sein de l'hôpital. Cependant, il a accès aux fonctionalitées des autres utilisateurs pour facilité l'évaluation de la plateforme et le débuggage  tous les services de l'hôpital se situe à la même adresse 
- il n'y a qu'un administrateur, du moins qu'un compte utilisateur d'administration de la plateforme
- Chaque intervention à des niveaux d'urgences (min et max) de référence relatif à la pathologie associée
- les niveau d'urgence minimum sont préétablit dans la base de donnée
- Tous les rendez-vous dur minutes  



2. L'organisation du code :
Le script étant assez long, il a été décomposé en plusieurs fichiers, qui étant aussi assez nombreux ont été réparti dans plusieurs répertoires organisé selon leurs type et fonctions. De plus, cette architecture du code, nous à permis de factoriser certaine partie du code en individualisant les blocs d'instructions réutilisés sous forme de fonctions. 
Ainsi, à la racine se trouve :
- le fichier index correspondant à la page d'accueil du site permettant de se connecter à celui-ci et d'accéder aux données de la base
- la classe Systeme: ...
- bdConfig : ...
- loggout qui permet de se déconnecter du site
- PagePrincipale sur laquelle l'utilisateur est redirigé une fois connecté et qui propose l'accès aux différentes fonctionalitées selon les droits d'accès de l'utilisateur 

on trouve aussi 6 répertoires : 
- BDD :  le fichier de structuration de la base de donnée, ainsi qu'un fichier comportant quelques insertions pour permettre les tests
- Images :  l'ensemble des images libres de droits et logo réalisés pour les aspects visuels
- Config : 
  		> Style.css qui structure l'ensemble des pages du site,
  		> MenuPage.php qui correspond au menu de navigation des l'ensemble des pages après validation de l'authentification cette page permet aussi de gérer les droit d'accès au utilisateur aux pages en disposant d'un affichage différentielle en fonction de la qualité de l'utilisateur ( pour palier au cas ou l'utilisateur saisie l'adresse dans la barre pour une page à laquelle il n'a pas de droit d'accès, la restriction d'accès est aussi renforcé sur chaque page par un test conditionnel de à la qualité de l'utilisateur lors de l'arrivée sur la page et une redirection si nécessaire ), 
  		> Footer : le pied de page permettant d'accéder aux contacts des développeurs et aux conditions d'utilisations
-  Formulaires : comporte l'ensemble des formulaires nécessaires au fonctionnement du site dont certains sont appelés par plusieurs pages tel que la recherche de patient, de service ou d'acte médical. 
 - Page : comporte 1 fichier pour chaque cas d'utilisation. Chacun de ces fichiers gère les redirections nécéssaire, renforcement de sécurité selon droit d'utilisation ou encore redirection vers la sélection d'un patient pour pouvoir demander un rendez-vous ou sélectionner un service pour suppression.  
 - Fonction : comporte 10 modules différents regroupant chacun un ensemble de fonctions organisé au seins de ses fichiers de manière thématique
 
 
 
 3.Détaille implémentation des cas d'utilisation 

a. Généralités sur les formulaires  
Les formulaire permettent à l'utilisateur de dialoguer avec la base de données, et ainsi d'insérer ou d'identifier et d'afficher des informations. Pour l'ensemble des formulaires établit, un bouton de validation permet de récupérer les valeurs saisie dans la variable '$_POST'. Différentes traitements sont imposées à chaque éléments de ce tableau pour faciliter la gestion d'erreur et limiter la redondance des données. Par exemple, la suppression des espaces ou encore le formatage des chaînes de caractère en minuscule avec la première lettre en majuscule. Si le format accepté par la base de donnée ou si l'un des champ devant être renseigné est vide (champ 'not null' dans la base de données, la gestion d'erreur prévoit l'interruption de la procédure et l'envoi d'un message à l'utilisateur pour l'informer du type d'erreur détecté. Pour les entrée dans des tables qui comportent des clé étrangères, soit la clé est récupérée dans la table parent s'il y a un tuple correspondant, soit à défaut elle est créée.

b. Insertion d'entrées dans la base de donnée
b1. Création de patient 
Cette page affiche un unique formulaire structuré selon la quantité et la qualité des informations nécessaires pour réaliser une nouvelle entrée sur la table 'Patients'. En effet pour cela, il faut au préalable avoir renseigné la table 'Villes' et l'ensemble des attributs qu'elle contient; ou bien récupérer la clé primaire d'un tuple dont l'ensemble des champs correspond aux informations de l'utilisateur ( ex: même ville, même code postal, même département, même pays). Ensuite, il faut renseigner la table 'Adresse' où la clef étrangère pointant sur ville est alors fournit par l'étape précédente. De même que pour l'étape précédente, le site vérifie si un tuple comporte un ensemble de valeurs d'attribut associé correspondant à l'entrée et récupère la clé primaire de celui-ci, ou effectue une nouvelle entrée si ce n'est pas le cas en récupérant la clef étrangère de celle-ci. Enfin, les données relative à la table patient sont insérées, ici encore en utilisant entre autre les données du formulaire d'une part et la clé primaire de la table parent récupérée à l'étape précédente. Le numéro de sécurité social étant unique, il garantit l'intégrité référentielle de cette table. 

b2. Création de compte utilisateur
Si l'utilisateur est l'administrateur, alors il a accès à l'onglet permettant d'accéder directement à cette page et il le test d'identité est validé. Le formulaire est alors généré et traité en cas de validation de manière similaire au cas de création de patient. Ici, la spécificité est que la clé primaire de la table Compte Utilisateur est généré automatiquement, en fonction des initiales de l'utilisateur et de 5 chiffres 'aléatoires' (basé sur la date courante).

b3. Création de service
Si l'utilisateur est l'administrateur, alors il a accès à l'onglet permettant d'accéder directement à cette page et il le test d'identité est validé. Comme pour les formulaires précédents, la structure est basé sur les informations a collecté pour réalisé l'entrée. La gestion d'erreur prévoit de tester l'éxistance ou l'ajout le cas échéant de la localisation du service qui représente une clé étrangère sur la table 'Services'. 

b4. Création d'un intervention
De manière similaire aux cas précédent, la page fait appel au formulaire 'recherche de service', si aucun service n'a été sélectionné au préalable ou 

b5.Demande de rendez-vous
Lorsqu'un utilisateur clique sur demande de rendez-vous, si aucun patient n'est sélectionné alors le formulaire de sélection de patient est appelé. Après validation, l'identifiant est stocké dans la variable '$_SESSION' et l'utilisateur est redirigé sur la même page. Lorsque cette variable est renseignée, alors la page appel dans ce cas un formulaire comportant les informations nécessaires pour réalisé l'entrée. Après validation, tous les cas de gestion d'erreur sont vérifiées. Si tous ces cas sont négatifs, alors la fonction ProchainCréneaux() est appelée. 
La fonction de recherche de créneau lance une requete sql composé de 4 parties : 
Min(Max(Max(rdv prévu auj.) + Max(rdv prévu>auj)) + Min(rdv annulé auj.) + Min(rdv annulé>auj.)) + une contrainte relative aux horaires du service
Cette requête retourne ainsi le dernier créneaux ocuppé ou le prochain créneaux disponible. Ainsi, selon le statut de se créneaux, 15 min si prévu (durée standard d'un rendez-vous). 
Si aucun retour n'est renvoyé par cette requête alors, si cette heure est inférieur à l'heure d'ouverture, on écrase l'heure du créneau par l'heure d'ouverture du service. En revanche, si l' heure est supérieur ou égale à l'heure d'ouverture alors on écrase l'heure par l'heure d'ouverture et on écrase la date par la date de demain. Sinon on attribut au créneaux, l'heure et la date actuelle. Si le niveau d'urgence est <, alors on appel la fonction de gestionUrgence(). Enfin, on test la compatibilité du niveau d'urgence et on insert le rendez-vous dans la table 'CreneauxIntervention'.

b6. Gestion des urgences
La première étape de cette fonction vise à établir l'heure et la date de fin du delais à compter de maintenant. Ensuite, le si le créneaux retourné par la fonction ProchainCréneaux() est compatible (<) avec le niveau d'urgence demandé alors la procédure se termine et le rendez-vous s'insère de manière classique. Si ce n'est pas le cas, une nouvelle requête est lancé pour rechercher 
-le dernier créneaux du planning dont le niveau d'urgence est >= au niveau demandé
-le premier créneaux annulé
Min(Max(Max(rdv prévu auj.) + Max(rdv prévu>auj)) + Min(rdv annulé auj.) + Min(rdv annulé>auj.)) + pas de contraintes relative aux niveaux d'urgences
S'il n'y a pas de créneaux de même niveau d'urgence déjà présent dans le planning est que le retour de la requête est un tableau vide, on attribut alors le rendez-vous immédiatement ( avec comme créneaux le jour d'aujourdhui et l'heure arrondie à la prochaine quinzaine). Tous les rendez-vous suivant sont décalées de 15 minutes jusqu'a ce que la boucle rencontre un rendez-vous dont le statut est annulé. 


b6. Enregistrement des notifications
Lorsqu'une intervention est demandée, la fonction de gestion d'attribution des créneaux appel deux fonctions relatives aux envoies de notification.
1. Elle test systématiquement ( car il y a un niveau minimum aussi ), s'il le niveau d'urgence demandé est compatible avec les niveaux de références. Si une incompatibilité est détecté, une notification est ajouté sur la Table notification. 
2. En cas de niveau d'urgence >0 , elle appel la fonction de vérification de surbooking. Si le dernier rendez vous de la journée du créneau attribué est >= à l'h de fermeture alors une notification, une notification est ajouté sur la Table notification. 
Chaque notification comporte l'identifiant du créneaux concerné ainsi que le nom du service auquel elle est attribuée ( ex. informatique adressée à l'administrateur dans le cas des notif 1., et cardiologie pour le chef de cardiologie dans le cas des notif 2)

C. Généralités sur l'affichage des pages
Plusieurs page propose un affichage dynamique pour permettre, entre autre, la sélection de pré-requis pour accéder aux étapes suivantes. Cette fonctionnalité est basé sur la pérènité des information contenue dans le  '$_SESSION' tout au long de la session d'utilisation. Pour assurer la modularité de cette dynamique, les clés générées pour l'affichage des pages sont systématiquement supprimées lors du retour sur la page d'accueil ( redirection assurée par bouton abandonné). D'autres association clé-valeur sont stockées dans cette variable tel que les nom, prénom et identifiant de l'utilisateur, ou encore ses droit d'utilisateur ( bool '$_SESSION['chef']').  D'autre valeurs de la base de donnée sont récupéré ponctuellement selon les besoins, comme lors des cas de modification. 

D. Mise à jour des entrées de la base de données 
d1. Modification de fiche patient
Cette page permet de mettre a jour les information d'une ou des tables associées à l'enregistrement d'un patient ( tables : 'Patients', 'Villes', 'Adresses' ), L'affichage se fait de manière différentielle selon le contenu de '$_SESSION'. Si ce tableau ne comporte pas de clé nommée 'patient' alors la page appel un formulaire ( du répertoire formulaire ), qui permet d'identifié un patient présent dans la base de donnée selon ses nom et prénom. Lors de la validation de la sélection, si aucune erreur n'est identifiée, alors la clé primaire identifiant le patient est affectée à  '$_SESSION['patient']' et l'utilisateur est alors redirigé vers cette même page. 
Quand cette variable existe alors la page affiche un formulaire de même structure que pour l'ajout d'un nouveau patient. Cependant, ici le formulaire affiche comme valeur par défaut, dans chaque champ, l'ensemble des informations associées au patient. Lors de la validation, les instruction de validation sont semblable concernant la gestion d'erreur au cas d'utilisation 'Ajout de patient', en revanche la requête correspondant plus à une insertion mais à une mise à jour.

d2. Modification de compte utilisateur
Si l'utilisateur est l'administrateur, alors il a accès à l'onglet permettant d'accéder directement à cette page et il le test d'identité est validé.Avec un affichage différentiel, le comportement de la page est identique à celui du cas précédent. De même, comme pour le cas de modification patient, le formulaire est généré selon la structure de création de compte utilisateur additionné de valeurs par défaut correspondant aux valeurs pré-existantes dans la base de données, pour le compte sélectionné. Il est à noté que l'utilisateur ne peut modifier son identifiant. 

d3.  Modification Service
Si l'utilisateur est l'administrateur, alors il a accès à l'onglet permettant d'accéder directement à cette page et il le test d'identité est validé. La logique de conception et d'implémentation de ce cas d'utilisation est identique au deux précédents cas de modification. 

d4. mise à jours des niveau d'urgence de référence et gestion des notifications
Les notifications stockées lors de la prise de l'attribution de créneaux, peuvent être consulté par les chefs de service. Ainsi lors de l'ouverture de la page, la fonction d'affichage recherche si l'utilisateur est chef pour restreindre l'accès, mais aussi recherche le service concerné pour affiché les notifications spécifiques. 
S'il existe des notifications alors, un tableau dynamique est généré en fonction du nombre de notifications mais aussi du nombre d'attributs. Des boutons sont aussi générés dynamiquement pour chaque intervention de manière à permettre de garantir la possibilité d'une interaction indépendante de l'utilisateur avec chaque notification. 
Comme vu précédemant, l'admin. recois des notifications en cas d'incompatibilité. Celui-ci peut choisir de mettre à niveau de la valeur de référence selon la demande de l'utilisateur, et ainsi supprimer la notification. Cependant, il peut aussi refuser la mise à jour et simplement supprimer la notification.
Les chefs de services ont accès au notifications de surbooking prévu dans leur service d'affectation, il peuvent consulter cette notification et la déclarer comme vu pour l'effacer. 

E. Généralités sur l'archivage 
Certaine tables ont été dédoublées avec l'appélation 'TableArchive' pour permettre de basculer des informations dans ces nouvelles tables. Cette manipulation permet de restreindre l'accès des utilisateurs à l'information mais de concerver une une trace des informations relative aux échanges d'intervention entre les services. En effet, par exemple si un service est définitivement fermé ou arrête de dispenser un acte alors, les utilisateurs ne pourront pas demander à tord de rendez-vous pour celui-ci. 

F. Suppression et archivage des données
f1. Suppression de compte utilisateur
Seul L'administrateur à accès a cet fonctionnalité. Il peut ainsi supprimé un utilisateur de la table 'Compte Utilisateur', cependant les données de la table 'employé' sont conservées. 

f2. Archivage d'acte médicaux
L'identité de l'utilisateur est testé, si celle ci correpond à l'administrateur alors la page archivage d'acte médicaux affiche de manière dynamique. Si aucun service n'est identifié dans '$_SESSION' alors il y a redirection vers le formulaire de recherche d'acte. 
Si un acte est identifié dans cette variable,  alors l'acte en question est basculé vers une table d'archive et l'utilisateur est redirigé vers la même page comportant un message de validation. Plusieurs gestion d'erreur garantissent encore ici le bon déroulement de la procédure ( variables non vide, idIntervention existant ...ect). 
Il est à noter, que cette table est la table parent de 'Tarification'. Ainsi, une table d'archivage a été créer. Les information relatives aux tarifs sont stocké dans une variables temporaire, l'intervention est déplacé dans la table d'archivage et le nouvelle identifiant attributé par auto-incrémentation est alors récupéré. Ainsi, l'étape final correspond à l'entrée du tarif sur la table TarificationArchivage avec comme valeurs de clé étrangère, la nouvelle clé primaire de l'acte.

D. Le traitement des requêtes 
Après exécution d'une requête mySQL, il est parfois nécessaire d'appliquer un traitement particulier pour accéder et manipuler les données retournées. La structure de ces données peut varier de la valeur d'un unique attribut à plusieurs de plusieurs attributs. Pour cela, le module 'Fonctions_reqTraitement.php' comporte l'implémentation de plusieurs fonctions de récupération (boucle while) et de réorganisation des retours de requêtes. Chaque fonction, parcours la requête et stock les information dans des tableau de 1, 2 ou 3 dimension selon les nécéssités. 

E. Planning
Lors que l'utilisateur arrive sur le planning, la page appel la fonction planning() pour récupérer l'ensemble des informations nécessaires. Cette fonction récupère les heure de début et de fin de service théorique et réelle, ainsi, l'affichage permet un nombre de ligne minimum en accord avec les horaires théorique du service, ou un ajustement à lheure réél en cas de surbooking. 
Le premier affichage est celui du planning du jour du service auquel l'utilisateur est rattaché. Cependant, l'utilisateur peut sélectionner un autre jour et une autre date pour naviguer dans le planning. De plus, l'affichage du planning peut générer un ensemble de bouton en fonction des caractéristiques du rendez-vous, de l'heure et de la date actuelle, et de l'utilisateur. En effet, pour un rendez-vous dont le statut est 'prévu' et dont la date/heure sont passés. Un bouton 'R' apparait, en cas de clique, le statut du créneaux correspondant est mis à jour et devient 'réalisé' permettant ainsi l'édition d'un facture.
Si l'utilisateur est le chef du service en question ou l'utilisateur ayant demandé le rendez-vous et que le créneaux n'est pas encore passé, alors des bouton annulés et modifié apparaissent. 
Le bouton supprimé, après confirmation, lance une requête de mise à jour du créneaux correspondant en modifiant le statut en 'annulé'. En revanche, le bouton mettre a jour individuellement les autres champs de la base de données relatif à ce rendez-vous. 


F. Visualisation des statistiques de demande de rendez-vous
Les données a affiché sont évalués grâce à l'utilisation de fonction SQL d'aggrégations. De plus, des structures de contrôle de type boucle ont permis d'itérer les requêtes, par exemple, pour compter le nombre de demande pour chaque niveau d'urgence. L'ensemble des données collectées sont stockées dans un tableau à 3 dimenssions. Les informations ainsi stockées sont ensuite retournées dans un tableau généré de manière dynamique grâce à des boucles en language php, qui génère les balises php nécéssaires. 

E Facturation
Si l'utilisateur est un chef, et qu'aucun patient n'est associé à la variable '$_SESSION' alors, un formulaire de sélection de patient est affiché. Après validation du choix de patient, si toutes les étapes de gestion d'erreur se déroule bien alors soit une facture comportant l'ensemble des actes réalisées s'affiche. Une requète recherche alors tous les rendez-vous dont le statut est 'réalisé' associés au patient sélectionné et au service de rattachement de l'utilisateur. Si des créneaux remplissant ces conditions sont sélectionnés, alors une facture apparait. Sinon, un message informe l'utilisateur qu'aucune intervention ne peuvent être facturé pour ce patient. L'utilisation de requête avec opérateurs arithmétique permet d'afficher les tarifs TTC et HT notamment. 





interventions demandé pour la pathologie en question et 

voir une vision d'ensemble des différentes opérations réalisées en relation avec les demandes d'interventions,






4. Conventions de nommage : 
Avant de passer à l'étape d'implémentation, quelques point ont été fixé pour faciliter la collaboration.

a.base de donnée
-les noms de table en majuscule avec un 's' à la fin 
-les nom d'attribut en minuscule sans 's', formatés selon la convention 'CamelCase' pour les nom composés de plusieurs mots
-les noms des clefs étrangères sont composés du nom de la table parent (même format de nommage) suivi du nom de l'attribut sur lequel il pointe (même format de nommage) 

b.Le code php : 
Les variables ont été nommées par un nom en relation avec le contenu selon les conventions 'CamelCase' pour les variables php et les conventions 'SnakeCase' pour les requètes  SQL. 
- les chaînes de caractères : $variable
- les tableau : $a_tableau
- les requêtes = $req_'nomObjet'














#-- !!!! Si c'était a refaire : 
- convention de nommage : nombre de a correspondant au nombre de dimensions de tableau (ex : $aa_tableau pour un tableau donc les valeurs sont des tableaux) 
- approche moins exploratoire dans un cadre professionnel, améliorer la logique et l'homogéneité  d'implémentation, ici on a surtout essayé de multiplier les méthodes pour arriver à nos fin à fin d'explorer les ressources de ces langage de programation que de réaliser une implémentation efficace. 

# !!! ajouter les cas utilisation : 
- notification : 1 pour tout le monde 
- ajout acte
 - archivage acte




